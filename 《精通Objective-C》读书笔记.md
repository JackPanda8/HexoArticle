##《精通Objective-C》读书笔记

### 第二章  使用类

1. 下划线访问属性与（点语法和getter/setter）访问属性的区别

   一般情况下，外部的类访问对象a的属性时，应当使用a.name或者[a name]方法，但是若在类内部，即对象a可能还没有创建好，此时应当使用 _name的下划线方式进行访问。

---

###第三章 对象和消息传递

1. 工厂方法

   工厂方法是指用于创建和初始化类的便捷方法，它是类方法，如下所示：

   ```objective-c
   //Class name : Person
   -(id) initWithName:(NSString*)name;
   +(id) personWithName:(NSString*)name;//工厂方法
   
   //implemention
   -(id) initWithName:(NSString*)name {
       if(self = [super init]) {
           _name = name;
       }
       return self;
   }
   +(id) personWithName:(NSString*)name {
       return [[[self class] alloc] initWithName:name];
   }
   ```

   在工厂方法中，使用[self class]获取当前实例对象对应的类，与直接使用类名相比，这种方式可以在被子类调用时，能够返回与子类相同的对象。

---

###第四章 内存管理

1. Objective-C可执行程序的组成

   可执行代码：二进制代码，存储于代码区域，以静态方式分配内存，与程序的生命周期相同。

   常量字符串：存储在常量区域，程序结束后由系统释放。

   

   链接信息：存储于静态（全局）区域，以静态方式分配内存，与程序的生命周期相同。

   重定位信息：存储于静态（全局）区域，以静态方式分配内存，与程序的生命周期相同。

   **初始化和未初始化的程序数据**：包括静态变量和程序常量，在编译期间进行初始化（static，const）。存储于静态 

   ​                                                （全局）区域，以静态方式分配内存，与程序的生命周期相同。

   

   **局部数据**：存储在栈中，包括局部变量、方法的输入参数、返回值、方法调用结束后继续执行程序的代码地址等。

   ​                  静态分配栈内存是编译器完成的，比如自动变量(auto)的分配； 动态分配栈内存由alloca函数完成。

   **动态数据**：运行时OC通过alloc方法动态创建的对象，存储在堆中，需要对其进行内存管理。

2. 栈与堆的区别

  栈：

  * 栈区中的变量由**编译器**负责分配和释放，由系统自动完成。只要栈的剩余空间大于所申请空间，系统将为程序提

    供内存，否则将报异常提示栈溢出。

  * 栈是**向低地址**扩展的数据结构，是一块**连续**的内存的区域。栈顶的地址和栈的最大容量是系统预先规定好的。

  堆：

  * 操作系统有一个**记录空闲内存地址的链表**。当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申

    请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。由于找到的堆结点的大

    小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中，所以容易产生内存碎片。

  * 堆是**向高地址**扩展的数据结构，是**不连续**的内存区域。


3. static、const、extern、和宏定义的区别与联系

   static：static修饰**局部变量**时延长其 **生命周期** 到程序结束，并且在内存中只有一份，不会改变局部变量的作用域；

   ​            static修饰**全局变量**，将其 **作用域** 限制在所在文件才能访问，生命周期不改变，仍旧是随程序一起结束。

   const：限制其**右边**的量为只读而不被改变。

   * 与static一起使用，定义一个静态常量：static  NSString * const key = @"name"; 【场景：在某一个文件中经常使用的常量】 
   * 与extern一起使用，定义一个全局常量：extern NSString* const key = @"name"; 【场景：在多个文件之间共享的常量，因为如果使用static const组合则需要在每个文件都定义一次；一般会新建一个GlobalConst的文件，统一管理extern const联合修饰的全局常量】

   extern：满足访问全局变量的需求，先在当前文件查找有没有全局变量，若没有找到，则会去其他文件查找 ；

   ​             extern int a;这里的a并不会分配内存，只是声明其为全局变量。 

   宏定义：#define NAME @“JackPanda”;    宏定义产生的常量与const定义的常量（只读变量）的区别：

   1. 宏的执行发生在预编译时期，const发生在编译时期。

   2. 宏只是进行替换，没有类型检查，不会报错；const会有类型检查，可以报错。

   3. 宏可以定义函数，const不可以。

   4. 大量使用宏会导致编译时间变久，因为每次都要重新替换。

4. 